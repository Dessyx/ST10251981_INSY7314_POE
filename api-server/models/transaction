// models/transaction.js

const db = require('../database');

class Transaction {
  static async getAll() {
    return db('transactions').select('*').orderBy('created_at', 'desc');
  }

  static async getAllWithUsers() {
    return db('transactions')
      .select(
        'transactions.*',
        'users.full_name as user_full_name',
        'users.username as user_username'
      )
      .leftJoin('users', 'transactions.user_id', 'users.id')
      .orderBy('transactions.created_at', 'desc');
  }

  static async getById(id) {
    if (!Number.isInteger(Number(id)) || id <= 0) {
      throw new Error('Invalid transaction ID');
    }
    return db('transactions').where({ id }).first();
  }

  static async getByUserId(userId) {
    if (!Number.isInteger(Number(userId)) || userId <= 0) {
      throw new Error('Invalid user ID');
    }
    return db('transactions').where({ user_id: userId }).orderBy('created_at', 'desc');
  }

  static async create({
    user_id,
    amount,
    currency,
    swift_code = null,
    recipient_name = null,
    provider = null,
    status = 'pending',
    description = ""
  }) {
    // --- Server-side validation ---
    if (!Number.isInteger(Number(user_id)) || user_id <= 0) {
      throw new Error('Invalid user ID');
    }
    if (typeof amount !== 'number' || amount <= 0) {
      throw new Error('Amount must be a positive number');
    }
    const allowedCurrencies = ['ZAR', 'USD', 'EUR', 'GBP'];
    if (!allowedCurrencies.includes(currency)) {
      throw new Error('Invalid currency');
    }
    if (swift_code && !/^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$/.test(swift_code)) {
      throw new Error('Invalid SWIFT code format');
    }
    if (recipient_name && (recipient_name.length < 2 || recipient_name.length > 100)) {
      throw new Error('Recipient name must be 2-100 characters');
    }
    if (provider && (provider.length < 2 || provider.length > 100)) {
      throw new Error('Provider name must be 2-100 characters');
    }

    // --- Sanitization ---
    const sanitizedData = {
      user_id: parseInt(user_id),
      amount: parseFloat(amount),
      currency: currency.toUpperCase(),
      swift_code: swift_code ? swift_code.toUpperCase() : null,
      recipient_name: recipient_name ? recipient_name.trim() : null,
      provider: provider ? provider.trim() : null,
      status: status.toLowerCase(),
      description: description ? description.trim() : '',
      created_at: db.fn.now(),
      updated_at: db.fn.now()
    };

    const [id] = await db('transactions').insert(sanitizedData);
    return db('transactions').where({ id }).first();
  }

  static async updateStatus(id, status) {
    if (!Number.isInteger(Number(id)) || id <= 0) {
      throw new Error('Invalid transaction ID');
    }
    const allowedStatuses = ['pending', 'verified', 'completed', 'failed', 'cancelled'];
    if (!allowedStatuses.includes(status)) {
      throw new Error('Invalid transaction status');
    }

    const updated = await db('transactions')
      .where({ id })
      .update({
        status: status.toLowerCase(),
        updated_at: db.fn.now()
      });

    if (updated > 0) {
      return db('transactions').where({ id }).first();
    }
    return null;
  }

  static async update(id, updates) {
    if (!Number.isInteger(Number(id)) || id <= 0) {
      throw new Error('Invalid transaction ID');
    }

    const allowedFields = ['amount', 'currency', 'swift_code', 'recipient_name', 'provider', 'status', 'description'];
    const filteredUpdates = {};

    Object.keys(updates).forEach(key => {
      if (allowedFields.includes(key)) {
        if (key === 'currency') {
          const allowedCurrencies = ['ZAR', 'USD', 'EUR', 'GBP'];
          if (!allowedCurrencies.includes(updates[key])) {
            throw new Error('Invalid currency');
          }
          filteredUpdates[key] = updates[key].toUpperCase();
        } else if (key === 'swift_code') {
          if (!/^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$/.test(updates[key])) {
            throw new Error('Invalid SWIFT code format');
          }
          filteredUpdates[key] = updates[key].toUpperCase();
        } else if (['recipient_name', 'provider', 'description'].includes(key)) {
          filteredUpdates[key] = updates[key].trim();
        } else if (key === 'status') {
          const allowedStatuses = ['pending', 'verified', 'completed', 'failed', 'cancelled'];
          if (!allowedStatuses.includes(updates[key])) {
            throw new Error('Invalid transaction status');
          }
          filteredUpdates[key] = updates[key].toLowerCase();
        } else {
          filteredUpdates[key] = updates[key];
        }
      }
    });

    if (Object.keys(filteredUpdates).length === 0) {
      throw new Error('No valid fields to update');
    }

    filteredUpdates.updated_at = db.fn.now();

    const updated = await db('transactions')
      .where({ id })
      .update(filteredUpdates);

    if (updated > 0) {
      return db('transactions').where({ id }).first();
    }
    return null;
  }

  static async delete(id) {
    if (!Number.isInteger(Number(id)) || id <= 0) {
      throw new Error('Invalid transaction ID');
    }
    return db('transactions').where({ id }).del();
  }

  static async getTransactionStats(userId = null) {
    let query = db('transactions');

    if (userId) {
      if (!Number.isInteger(Number(userId)) || userId <= 0) {
        throw new Error('Invalid user ID');
      }
      query = query.where({ user_id: userId });
    }

    const stats = await query
      .select(
        db.raw('COUNT(*) as total_transactions'),
        db.raw('SUM(amount) as total_amount'),
        db.raw('AVG(amount) as average_amount'),
        db.raw('COUNT(CASE WHEN status = ? THEN 1 END) as completed_count', ['completed']),
        db.raw('COUNT(CASE WHEN status = ? THEN 1 END) as pending_count', ['pending']),
        db.raw('COUNT(CASE WHEN status = ? THEN 1 END) as failed_count', ['failed'])
      )
      .first();

    return stats;
  }
}

module.exports = Transaction;
